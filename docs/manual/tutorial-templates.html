<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<!--

		Arrow Manual: Templating Tutorial
		$Id$

		Author:		Michael Granger
		Time-stamp: <23-Apr-2001 19:58:12 deveiant>

  -->

  <head>
	<title>Arrow Manual: Templating Tutorial</title>

	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta http-equiv="Content-Script-Type" content="text/javascript" />

    <meta name="authors" content="Michael Granger (ged@FaerieMUD.org)>" />
	<link rel="stylesheet" href="manual.css" type="text/css" />
  </head>
  <body>


	<!--#include virtual="linkbox.incl" -->
	<!--#include virtual="tutorial-linkbox.incl" -->

	<div id="content">
	  <h1>Arrow: Templating Tutorial</h1>

	  <div class="section">
		<h2>Templates</h2>
		<p>
		  Putting code and html together (either html in the code or vice versa)
		  becomes unwieldy and ugly after a certain level of complexity (a
		  little after "hello world"), and for this reason, web developers have
		  traditionally used templates to separate off all the display work.
		  There is debate over exactly how much power a templating system should
		  have (should it be able to execute arbitrary code, or only adhere to a
		  small set of tools), and the construction of a templating system is
		  relatively easy, so templating systems are many and diverse.  We have
		  included with Arrow our own templating system - complete, extensible
		  and (we think) intuitive - but have also made it easy for you to use
		  any other templating system.  If you already have a favorite, and have
		  no interest in seeing another, (even if you might like it,) you can
		  skip past the tutorial on ours and learn <a href="#others">how to use
		  your own</a>.
		</p>
		<p>
		  Template handling is, to some degree, integrated with the Arrow
		  server.  The arrow config file has a templates section.
		</p>
	  </div>
	  <div class="section">
		<h2><a href="#ats" id="ats">Arrow Templating System</a></h2>
		<p></p>
		<h2>Syntax</h2>
		<p>The Arrow Templating System uses preprocessing tags to distinguish
		template directives.  These are both &lt;?...?&gt; and [?...?], with the
		square bracket version to be used inside of other html tags (as in:
		&lt;a href="[?attr link?]"&gt;...)</p>
		<h2>The Directives</h2>
		<p></p>
        <h3>attr</h3>
		<p><strong>&lt;?attr var?&gt;</strong> A simple directive, this
		replaces itself with the stringified contents of the template variable
		specified.</p>
        <h3>call</h3>
		<p><strong>&lt;?call var.method(args)?&gt;</strong> This allows method
		calls on a variable to be evaluated, including arguments taken from the
		template variables or some basic ruby (such as numbers and strings).</p>
        <h3>set</h3>
		<p><strong>&lt;?set var value?&gt;</strong> Sets a template variable to
		the specified value, which will then be accessible through the rest of
		the template.</p>
        <h3>escape</h3>
		<p><strong>&lt;?escape statement?&gt;</strong> Entity-ifies the return
		of the statement (so turns all &lt;'s, &gt;'s and &amp;'s into their
		corresponding &amp;blah;'s).</p>
        <h3>if/elsif/else</h3>
		<p><strong>&lt;?if statement?&gt;...&lt;?elsif
		statement?&gt;...&lt;?else?&gt;...&lt;?end if?&gt;</strong> Your run of
		the mill conditional flow control.  The 'else' is optional, the 'elsif's
		can be repeated any number of times (including zero), and the
		'statement' can be any template variable, method chain off a template
		variable, or regular expression match of a template variable (like
		&lt;?if var.method =~ /regex/?&gt;).</p>
        <h3>for</h3>
		<p><strong>&lt;?for arglist in iterable?&gt;...&lt;?end for?&gt;</strong>
		For each element of the Enumerable object, the element is assigned to a
		template variable (or multiple, if appropriate), and the enclosed
		segment of XHTML is evaluated.  The arglist can have default values (as
		in: &lt;?for a,b=1 in a_hash?&gt;), array-slurping arguments (*args) and
		hashified arguments.  This will call Enumerable#each on the iterable.</p>
        <h3>yield</h3>
		<p><strong>&lt;?yield arglist from var.block_accepting_method?&gt;
		... &lt;?end yield?&gt;</strong> For calling any general method that
		takes a block, the yield directive will assign the arglist in the same
		fasion as with &lt;?for, then pass in the contained XHTML (the '...'
		above) to be evaluated in the method whenever yield is called (or
		&block.call, depending on how the method deals with the block argument).
		This can behave exactly like &lt;?for (&lt;yield arglist in
		var.each?&gt;), can be used to call alternate iteration methods (such as
		#each_with_index), or used in other general case block situations (like
		Regex#match).</p>
		<!-- :MC: i don't understand what this does enough to document it -->
        <!-- <h3>import</h3>
		<p><strong>&lt;?import foo as superfoo, bar, baz as
		bazish?&gt;</strong> Loads in template variables, either named the same
		as the variable, or renamed to match the 'as name' name.</p> -->
        <h3>include</h3>
		<p><strong>&lt;?include other_template.tmpl as name?&gt;</strong> This
		directive is replaced with the contents of the template specified, and
		then evaluated in either the present template's namespace, or in a
		subspace specified by 'name'.</p>
	  </div>
	  <div class="section">
		<h2><a href="#example" id="example">Templated Applets - Hello World
		(templated)</a></h2>
		<p>
		  The Signature of an app has room for mention of the templates it uses.
		</p>
	  </div>
	  <div class="section">
		<h2><a href="#adding" id="adding">Renderers</a></h2>
		<p></p>
	  </div>
	  <div class="section">
		<h2><a href="#adding" id="adding">Adding Directives</a></h2>
		<p></p>
		<h2>Sample Directive</h2>
		<p></p>
	  </div>
	  <div class="section">
		<h2><a href="#others" id="others">Using Other Templating Systems</a></h2>
		<p></p>
		<h2>Writing a Loader</h2>
		<p></p>
	  </div>

	</div>

  </body>
</html>


<!--
  Local Variables:
  mode: nxml
 -->
