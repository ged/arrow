<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<!--

		Arrow Manual: Templating Tutorial
		$Id$

		Author:		Michael Granger
		Time-stamp: <23-Apr-2001 19:58:12 deveiant>

  -->

  <head>
	<title>Arrow Manual: Templating Tutorial</title>

	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta http-equiv="Content-Script-Type" content="text/javascript" />

    <meta name="authors" content="Michael Granger (ged@FaerieMUD.org)>" />
	<link rel="stylesheet" href="manual.css" type="text/css" />
  </head>
  <body>



	<!-- Experimental linkbox thingie -->
	<div id="linkbox">
	  <span id="linkbox-head">Arrow Manual</span>
	  <span id="linkbox-body">
		<ul>
		  <li>[<a href="index.html">Index</a>]</li>
		  <li>[<a href="whatis.html">What Is Arrow?</a>]</li>
		  <li>[<a href="download.html">Downloading</a>]</li>
		  <li>[<a href="install.html">Installation</a>]</li>
		  <li>[<a href="config.html">Configuration</a>]</li>
		  <li>[<a href="tutorial.html">Tutorial</a>]</li>
		  <li>[<a href="html/">API Reference</a>]</li>
		</ul>
	  </span>
	</div>


	<!-- Tutorial linkbox thingie -->
	<div id="sub-linkbox">
	  <span id="sub-linkbox-head">&rarr; Tutorial</span>
	  <span id="sub-linkbox-body">
		<ul>
		  <li>[<a href="tutorial-intro.html">Intro</a>]</li>
		  <li>[<a href="tutorial-apps.html">Applets</a>]</li>
		  <li>[<a href="tutorial-templates.html">Templates</a>]</li>
		  <li>[<a href="tutorial-sessions.html">Sessions</a>]</li>
		  <li>[<a href="tutorial-validation.html">Input Validation</a>]</li>
<!-- 		  <li>[<a href="tutorial-sources.html">Data Sources</a>]</li> -->
<!-- 		  <li>[<a href="tutorial-monitors.html">Monitors</a>]</li> -->
		</ul>
	  </span>
	</div>

	<div id="content">
	  <h1>Arrow: Templating Tutorial</h1>

	  <div class="section">
		<h2>Templates</h2>
		<p>
		  Putting code and html together (either html in the code or vice versa)
		  becomes unwieldy and ugly after a certain level of complexity (a
		  little after "hello world"), and for this reason, web developers have
		  traditionally used templates to separate off all the display work.
		  There is debate over exactly how much power a templating system should
		  have (should it be able to execute arbitrary code, or only adhere to a
		  small set of tools), and the construction of a templating system is
		  relatively easy, so templating systems are many and diverse.  We have
		  included with Arrow our own templating system - complete, extensible
		  and (we think) intuitive - but have also made it easy for you to use
		  any other templating system.  If you already have a favorite, and have
		  no interest in seeing another, (even if you might like it,) you can
		  skip past the tutorial on ours and learn <a href="#others">how to use
		  your own</a>.
		</p>
		<p>
		  Template handling is, to some degree, integrated with the Arrow
		  server.  The arrow config file has a templates section.
		</p>
	  </div>
	  <div class="section">
		<h2><a href="#ats" id="ats">Arrow Templating System</a></h2>
		<p></p>
		<h2>Syntax</h2>
		<p>The Arrow Templating System uses preprocessing tags to distinguish
		template directives.  These are both &lt;?...?&gt; and [?...?], with the
		square bracket version to be used inside of other html tags (as in:
		&lt;a href="[?attr link?]"&gt;...)</p>
		<h2>The Directives</h2>
		<p></p>
        <h3>attr</h3>
		<p><strong>&lt;?attr var?&gt;</strong> A simple directive, this
		replaces itself with the stringified contents of the template variable
		specified.</p>
        <h3>call</h3>
		<p><strong>&lt;?call var.method(args)?&gt;</strong> This allows method
		calls on a variable to be evaluated, including arguments taken from the
		template variables or some basic ruby (such as numbers and strings).</p>
        <h3>set</h3>
		<p><strong>&lt;?set var value?&gt;</strong> Sets a template variable to
		the specified value, which will then be accessible through the rest of
		the template.</p>
        <h3>escape</h3>
		<p><strong>&lt;?escape statement?&gt;</strong> Entity-ifies the return
		of the statement (so turns all &lt;'s, &gt;'s and &amp;'s into their
		corresponding &amp;blah;'s).</p>
        <h3>if/elsif/else</h3>
		<p><strong>&lt;?if statement?&gt;...&lt;?elsif
		statement?&gt;...&lt;?else?&gt;...&lt;?end if?&gt;</strong> Your run of
		the mill conditional flow control.  The 'else' is optional, the 'elsif's
		can be repeated any number of times (including zero), and the
		'statement' can be any template variable, method chain off a template
		variable, or regular expression match of a template variable (like
		&lt;?if var.method =~ /regex/?&gt;).</p>
        <h3>for</h3>
		<p><strong>&lt;?for arglist in iterable?&gt;...&lt;?end for?&gt;</strong>
		For each element of the Enumerable object, the element is assigned to a
		template variable (or multiple, if appropriate), and the enclosed
		segment of XHTML is evaluated.  The arglist can have default values (as
		in: &lt;?for a,b=1 in a_hash?&gt;), array-slurping arguments (*args) and
		hashified arguments.  This will call Enumerable#each on the iterable.</p>
        <h3>yield</h3>
		<p><strong>&lt;?yield arglist from var.block_accepting_method?&gt;
		... &lt;?end yield?&gt;</strong> For calling any general method that
		takes a block, the yield directive will assign the arglist in the same
		fasion as with &lt;?for, then pass in the contained XHTML (the '...'
		above) to be evaluated in the method whenever yield is called (or
		&block.call, depending on how the method deals with the block argument).
		This can behave exactly like &lt;?for (&lt;yield arglist in
		var.each?&gt;), can be used to call alternate iteration methods (such as
		#each_with_index), or used in other general case block situations (like
		Regex#match).</p>
		<!-- :MC: i don't understand what this does enough to document it -->
        <!-- <h3>import</h3>
		<p><strong>&lt;?import foo as superfoo, bar, baz as
		bazish?&gt;</strong> Loads in template variables, either named the same
		as the variable, or renamed to match the 'as name' name.</p> -->
        <h3>include</h3>
		<p><strong>&lt;?include other_template.tmpl as name?&gt;</strong> This
		directive is replaced with the contents of the template specified, and
		then evaluated in either the present template's namespace, or in a
		subspace specified by 'name'.</p>
	  </div>
	  <div class="section">
		<h2><a href="#example" id="example">Templated Applets - Hello World
		(templated)</a></h2>
		<p>
		  First, we need to tell Arrow what kind of templates to use, where to
		  look for templates, and various other configuration options.  These
		  settings are kept in the Arrow config file, under the templates
		  section:
<pre>templates: 
  loader: Arrow::Template
  path:
    - "/www/templates"
  cache: true
  cacheConfig: 
    maxObjSize: 131072
    maxNum: 20
    expiration: 36
    maxSize: 2621440
</pre>
		  Here, "loader" is the templating system to use, "path" is a list of
		  directories to search for the templates, and the "cache" and
		  "cacheConfig" determine how to cache templates, balancing between
		  increased response time and decreased resource usage.
		</p>
		<p>
		  Now we can access and use our templates in an Applet.  As a
		  convenience, the Signature of an applet has room for mention of the
		  templates it uses.
<pre># Applet signature
Signature = {
    :name => "Hello World",
    :description => %{A 'hello world' applet.},
    :maintainer => "ged@FaerieMUD.org",
    :defaultAction => 'templated',
    <font color="#aa00aa">:templates => {
        :templated     => 'hello-world.tmpl',
    },</font>
}
</pre>
		  Which then further allows the use of the Arrow::Applet#loadTemplate
		  method to get an Arrow::Template object.  This is mostly just for you
		  to fill with data, and then make the return value of an action:
<pre>action( 'templated' ) {|txn, *args|
    self.log.debug "In the 'templated' action of the %s applet." %
        self.signature.name

    <font color="#aa00aa">templ = self.loadTemplate( :templated )
    templ.txn = txn
    templ.time = Time.now.to_s
    templ.applet = self

    return templ</font>
}
</pre>
		</p>
		<p>
		  So now we need to actually have a /www/templates/hello-world.tmpl file
		  made to display our page how we want it.
<pre>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"&gt;

&lt;!--

  Arrow "Hello World" Applet Template

  --&gt;

  &lt;head&gt;
	&lt;title&gt;Arrow: Hello World&lt;/title&gt;
	&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
	&lt;meta http-equiv="Content-Script-Type" content="text/javascript" /&gt;
	&lt;link rel="stylesheet" type="text/css" href="/stylesheets/arrow.css" /&gt;
  &lt;/head&gt;
  &lt;body&gt;

	&lt;h1&gt;Hello World&lt;/h1&gt;

	&lt;p&gt;It is &lt;?attr time?&gt;.  This is a minimal demo applet that just
	loads and prints a template.  There's also &lt;a href="<font
	color="#aa00aa">[?call txn.action?]</font>/display"&gt;a simpler
	version&lt;/a&gt; of this applet that outputs plain text (i.e., no
	templates).&lt;p&gt;

		&lt;!-- Runcount: <font color="#aa00aa">[?call applet.runCount ?]</font> --&gt;

<font color="#aa00aa">&lt;?if txn.session? ?&gt;</font>
	  &lt;!-- Session found --&gt;
  <font color="#aa00aa">&lt;?if txn.session[:user] ?&gt;</font>
	&lt;p&gt;Since you're logged in as '<font color="#aa00aa">&lt;?call
	txn.session[:user]?&gt;</font>', you can also &lt;a
		href="<font color="#aa00aa">[?call txn.appRoot?]</font>/<font
		color="#aa00aa">[?call txn.appletPath.split(%r{/})[0]
		?]</font>/logout"&gt;log out&lt;/a&gt; to test the protectedness
	  of the applet chain.&lt;/p&gt;
  <font color="#aa00aa">&lt;?end?&gt;</font>

<font color="#aa00aa">&lt;?end if ?&gt;</font>

	<font color="#aa00aa">&lt;?include navbar.incl?&gt;</font>

  &lt;/body&gt;
&lt;/html&gt;


&lt;!--
  Local Variables:
  mode: xml
 --&gt;
</pre>
		  Which is, for the most part, just static XHTML that will be displayed
		  verbatim.  The template directives designate places where the display
		  will be determined by the data that had been saved into the
		  Arrow::Template object in the action itself.  This template makes use
		  of the attr, call, if, and include directives, as described above.
		</p>
	  </div>
	  <div class="section">
		<h2><a href="#adding" id="adding">Renderers</a></h2>
		<p></p>
	  </div>
	  <div class="section">
		<h2><a href="#adding" id="adding">Adding Directives</a></h2>
		<p></p>
		<h2>Sample Directive</h2>
		<p></p>
	  </div>
	  <div class="section">
		<h2><a href="#others" id="others">Using Other Templating Systems</a></h2>
		<p></p>
		<h2>Writing a Loader</h2>
		<p></p>
	  </div>

	</div>

  </body>
</html>


<!--
  Local Variables:
  mode: nxml
 -->
